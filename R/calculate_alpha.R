#' Compute table of data spread and Cronbach alpha
#' 
#' Alpha, a commonly accepted measure of internal consistency needs to be computed from actual data rather than theory. Data that have very little variability within a case have high internal consistency. This helper function creates a series of simulated data points with random noise added drawn from a normal distribution of varying standard distribution from 0 to 4. Alpha is then calculated for each set of results and a summary table is returned.  This is a slow function and it is very unlikely you actually want to be calling it.
#'
#' @param scalelength How many items are in the simulated scale? This should match the Likert Scale you are trying to replicate.
#' @param samples How many runs should be undertaken? More is generally better and will result in less noise at low consistency, but this is at the expense of speed.
#' @param cases How many cases should be generated for each simulation run.
#'
#' @return a 2 column tibble of class alphatable
#' @export
#'
#' @examples
#' make_alpha_table()
#' 
#' make_alpha_table(scalelength = 7, samples = 8)
#' 
make_alpha_table <- function(scalelength = 5, samples = 5, cases=5000){
  t <- tibble::tibble(sd = numeric(),
                      alpha = numeric()
  )
  
  for (s in 1:samples){
    for(delta in seq(0,4, by = 0.02)){
      df <- tibble::tibble(x = stats::rnorm(cases,0,1))
      for(n in 1:scalelength){
        df <- df %>%
          dplyr::mutate("y{n}" := x + stats::rnorm(cases,0,delta))
      }
      df <- df %>%
        dplyr::mutate(Response = dplyr::select(., tidyr::matches("^y[1-9]+")) %>%
                        rowMeans(na.rm = TRUE),
                      Deviation = Response - x)
      tmp <- tibble::tibble(sd = delta,
                            alpha =alpha(df%>%dplyr::select(tidyr::matches("^y[1-9]+"))))
      t <- dplyr::bind_rows(t,tmp)
    }
  }
  class(t) <- c("alphatable",class(t))
  return(t)
}

#' Checking data classes of alphatable
#'
#' Check if an object contains all the necessary information to be an alphatable model
#' @param x any R object
#'
#' @return returns TRUE it its argument is an alphatable dataframe or FALSE otehrwise
#' @export
#'
#' @examples
#' x <- tibble::tibble(sd = seq(0,1, by=0.1), alpha = (1 - sd))
#' is.alphatable(x)
#' 
#' x <- make_alpha_table()
#' is.alphatable(x)
#' 
is.alphatable <- function(x){
  inherits(x,"alphatable")
}

#' Draw a plot showing the quality of the fit between 
#'
#' @param x a dataset of class alphatable
#' @param ... values passed to other functions
#'
#' @return ggplot2 object
#' @export
#'
#' @examples
#' \donttest{
#' x <- make_alpha_table()
#' plot_alpha_curve(x)
#' }
#' 
plot_alpha_curve <- function(x,...){
  if(!is.alphatable(x)){
    stop("This function only works with alphatable objects!!")
  }
  params <- determine_alpha_fit(data = x)$coefficients
  p <- x %>%
    ggplot2::ggplot(ggplot2::aes(y = `sd`^sqrt(2), x = log(alpha))) +
    ggplot2::geom_point() +
    ggplot2::geom_function(fun = \(x){params$intercept +params$slope * x}, color = "red") +
    ggplot2::labs(x = "ln(&alpha;)", y = "&sigma;<sup>&Sqrt;2</sup>") +
    ggplot2::theme(axis.title = ggtext::element_markdown())
  return(p)
}

#' Calculate Cronbach Alpha
#' 
#' Using a wide dataframe compute the value of Cronbach alpha across all numeric columns.
#'
#' @param data a dataframe or tibble
#'
#' @return a numeric value for alpha
#' @export
#'
#' @examples
#' d <- tibble::tibble(
#'   I1 = c(6,5,9,3,2,1,5), 
#'   I2 = c(6,5,8,2,3,1,4), 
#'   I3 = c(8,6,6,4,2,2,6)
#' )
#' alpha(d)
#' 
alpha <-function(data){
  V <- data %>%
    dplyr::select(tidyselect::where(is.numeric))%>%
    dplyr::mutate(Total = rowSums(dplyr::across(tidyselect::where(is.numeric)), na.rm = TRUE))%>%
    stats::var(na.rm = TRUE)%>%
    diag()
  
  k <- length(V) - 1
  var_total <- V[length(V)]
  var_i <- sum(V) - var_total
  alpha <- (k / (k-1)) * (1 - (var_i / var_total))
  
  return(alpha)
}

#' Calculate coefficients needed to compute alpha and spread
#' 
#' This helper function simulates cases and determines the parameters of the best fit curve needed to compute alpha. This function looks for a data frame generated by make_alpha_table and if it can't be found generates this.
#'
#' @param scalelength How many items are in the simulated scale? This should match the Likert Scale you are trying to replicate.
#' @param samples How many runs should be undertaken? More is generally better and will result in less noise at low consistency, but this is at the expense of speed.
#' @param data optional dataframe of class alphatable to speed up processing by reusing pre-generated data
#' @param ... further arguments passed to or from other methods
#'
#' @return an object of class alphafit
#' @export
#'
#' @examples
#' determine_alpha_fit()
#' 
determine_alpha_fit <- function(scalelength = 5, samples = 5, data = NULL, ...){
  df <- NULL
  if(!is.null(data)){
    if("alphatable" %in% class(data)){
      df <- data
    }
  }
  if(is.null(df)){
    df <- make_alpha_table(scalelength = scalelength, samples = samples)
  }
  res <- summary(
    stats::lm(formula = sd^(sqrt(2)) ~ log(alpha),
       data = df)
  )
  rtn <- list("coefficients" = list("intercept" = res$coefficients[1], "slope" = res$coefficients[2]),
              "fit" = list("RSE" = res$sigma, "R^2" = res$r.squared))
  class(rtn) <- "alphafit"
  return(rtn)
}

#' Generic Print Method for class(alphafit)
#'
#' @param x an object of class alphafit
#' @param ... further arguments passed to or from other methods
#'
#' @return Output to StdOut
#' @export
#'
#' @examples
#' x <- determine_alpha_fit()
#' print(x)
#' 
print.alphafit <- function(x, ...){
  cat("Fit Parameters\n")
  cat("  Intercept    Slope\n")
  cat("    ")
  cat(format(x$coefficients$intercept,width = 7, digits = 4, nsmall = 3, justify = "right"))
  cat("  ")
  cat(format(x$coefficients$slope,width = 7, digits = 4, nsmall = 3, justify = "right"))
  cat("\n\nFormula used to determine Rho\n")
  cat("rho = exp(sqrt(2) * log(",signif(x$coefficients$slope,4)," * log(alpha) + ",signif(x$coefficients$intercept,4),"))")
  cat("\n\nResidual standard error (RSE) in fitted curve: ",x$fit$RSE,"\n")
}

#' Checking data classes of alphafit
#'
#' Check if an object contains all the necessary information to be an alphafit model
#' @param x any R object
#'
#' @return returns TRUE it its argument is an alphafit model or FALSE otehrwise
#' @export
#'
#' @examples
#' x <- tibble::tibble(n = seq(1,100))
#' is.alphafit(x)
#' 
#' x <- determine_alpha_fit()
#' is.alphafit(x)
#' 
is.alphafit <- function(x){
  inherits(x,"alphafit")
}

#' Estimate the necessary value of rho
#' 
#' @description
#' In `generateDF()` and `generateData()` the parameter `rho` controls the variability within the responses for **each** respondent(case) if a multi item scale is being created. This parameter corresponds to the standard deviation of the distribution used to generate the individual item responses and is dependent on the number of items in the Likert scale and the intended internal consistency (measured using Cronbach alpha for simplicity). This function allows for a value of rho to be determined relatively easily.
#' 
#' **NOTE:** The underlying model generation function `determine_alpha_fit()` is quite noisy for alpha < 0.4. Increasing `samples` in that function will increase precision at the expense of speed.
#' 
#' @details
#' While Cronbach alpha is often considered to be an OK measure of internal consistency, it is often abused as a measure of reliability (see details section of [psych::alpha()] for a good discussion on the topic). We use it here purely for convenience and due its familiarity with users. Various cut off points have been suggested, and these do vary quite widely with field.  We suggest the following cut offs and qualitative descriptions as a rule of thumb when simulating data sets
#' 
#' |Cronbach Alpha|Interpretation|
#' |:---:|:----|
#' |≥0.9|Excellent consistency|
#' |≥0.8|Good level of consistency|
#' |≥0.7|Reasonable level of consistency|
#' |≥0.6|Questionable level of consistency|
#' |<0.6|Concerning level of consistency or Inconsistent|
#' 
#'
#' @param alpha The desired level of Cronbach alpha to simulate
#' @param model A model created by `determine_alpha_fit()`
#'
#' @return A numeric value for rho
#' @export
#'
#' @seealso [determine_alpha_fit()]
#' @seealso [generateData()]
#' 
#' @examples
#' m <- determine_alpha_fit()
#' estimate_rho(alpha = 0.8, model = m)
#' 
estimate_rho <-function(alpha, model){
  if(!is.alphafit(model)){
    stop("A valid alphafit model has not been supplied. Please make sure you call `determine_alpha_fit()` to generate the necessary model first!")
  }
  if(!is.numeric(alpha)){
    stop("Alpha must be a numeric value between 0 and 1")
  }
  if(any(!between(as.numeric(alpha),0,1))){
    stop("Alpha must be a numeric value between 0 and 1")
  }
  r <- ifelse(alpha == 1,
              0,
              ifelse(alpha == 0,
                     Inf, 
                     exp(sqrt(2) * log(model$coefficients$slope * log(as.numeric(alpha)) + model$coefficients$intercept))
                     )
              )
  return(r)
}

#' Plot the Alpha to Rho Calibration curve
#' 
#' Rho for use in `generateData()` is determined by simulation and the generation of an approximate equation essentially making use of a calibration curve. Use this function to show that calibration curve
#'
#' @param model an alphafit model
#'
#' @return a ggplot2 object
#' @export
#'
#' @examples
#' m <- determine_alpha_fit()
#' plot_rho_curve(m)
#' 
plot_rho_curve <-function(model){
  if(!is.alphafit(model)){
    stop("A valid alphafit model has not been supplied. Please make sure you call `determine_alpha_fit()` to generate the necessary model first!")
  }
    df <- tibble::tibble(alpha = seq(0,1, by = 0.01),
                         rho = estimate_rho(alpha,model))
    p <- df %>%
      dplyr::mutate(rho = dplyr::case_when(rho == Inf ~ NA, TRUE ~ rho)) %>%
      tidyr::drop_na()%>%
      ggplot2::ggplot(ggplot2::aes(x = alpha, y = `rho`)) +
      ggplot2::geom_point() +
      ggplot2::geom_smooth(formula = y ~ log(x), method = "loess", se = FALSE, colour = "red")+
      ggplot2::labs(x = "&alpha;", y = "&rho;") +
      ggplot2::theme(axis.title = ggtext::element_markdown())
    return(p)
}